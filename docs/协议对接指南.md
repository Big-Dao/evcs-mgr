# 协议对接指南 (Protocol Integration Guide)

> **English**: Guide for integrating OCPP and cloud charging protocols  
> **最后更新**: 2025-10-20  
> **维护者**: EVCS Protocol Team  
> **状态**: 已发布  
> **版本**: 1.0  
> **目标读者**: 协议开发人员、系统集成工程师

## 目录

- [一、概述](#一概述)
- [二、系统架构](#二系统架构)
- [三、OCPP协议对接](#三ocpp协议对接)
- [四、云快充协议对接](#四云快充协议对接)
- [五、事件发布](#五事件发布)
- [六、消息队列配置](#六消息队列配置)
- [七、测试验证](#七测试验证)
- [八、常见问题](#八常见问题)

---

## 一、概述

本指南介绍如何将新的充电桩协议接入EVCS Manager系统，包括OCPP和云快充两种协议的对接方法。

---

## 二、系统架构

### 2.1 协议层次结构

```
┌───────────────────────────────────────────────┐
│              应用层 (Application)              │
│  (订单服务、充电桩服务、计费服务)                │
└───────────────────────────────────────────────┘
                    ↑ 事件消费
┌───────────────────────────────────────────────┐
│            消息队列层 (RabbitMQ)               │
│  (交换机、队列、路由键、死信队列)                │
└───────────────────────────────────────────────┘
                    ↑ 事件发布
┌───────────────────────────────────────────────┐
│            协议适配层 (Protocol Adapter)        │
│  (OCPPProtocolService, CloudChargeProtocolService) │
└───────────────────────────────────────────────┘
                    ↑ 协议报文
┌───────────────────────────────────────────────┐
│         传输层 (WebSocket / HTTP)              │
│  (OCPP WebSocket, CloudCharge REST API)       │
└───────────────────────────────────────────────┘
```

---

## 三、OCPP协议对接

### 3.1 OCPP概述

- **协议版本**: OCPP 1.6 / OCPP 2.0.1
- **传输方式**: WebSocket
- **消息格式**: JSON

### 3.2 关键消息类型

| OCPP消息 | 对应事件 | 说明 |
|---------|---------|------|
| BootNotification | - | 充电桩启动通知 |
| Heartbeat | HeartbeatEvent | 心跳 |
| StatusNotification | StatusEvent | 状态变更 |
| StartTransaction | StartEvent | 开始充电 |
| StopTransaction | StopEvent | 停止充电 |
| MeterValues | - | 实时数据上报 |

### 3.3 实现步骤

#### 步骤1: 实现协议接口

```java
@Service
public class OCPPProtocolServiceImpl implements IOCPPProtocolService {
    private final ProtocolEventPublisher eventPublisher;
    
    @Override
    public boolean sendHeartbeat(Long chargerId) {
        // 发布心跳事件
        eventPublisher.publishHeartbeat(
            chargerId, 
            getTenantId(), 
            "OCPP", 
            LocalDateTime.now()
        );
        return true;
    }
    
    @Override
    public boolean startCharging(Long chargerId, String sessionId, Long userId) {
        // 发送OCPP RemoteStartTransaction命令
        // ...
        
        // 发布开始充电事件
        eventPublisher.publishChargingStart(
            chargerId, 
            getTenantId(), 
            "OCPP", 
            sessionId, 
            userId, 
            orderNo,
            0.0,  // initialEnergy
            true, 
            "OK"
        );
        return true;
    }
}
```

#### 步骤2: WebSocket连接管理

```java
@Component
public class OCPPWebSocketHandler extends TextWebSocketHandler {
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        log.info("OCPP connection established: {}", session.getId());
        // 注册会话
        sessionRegistry.register(session);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        // 解析OCPP消息
        OCPPMessage msg = parseMessage(message.getPayload());
        
        // 根据消息类型分发处理
        switch (msg.getMessageType()) {
            case HEARTBEAT:
                handleHeartbeat(session, msg);
                break;
            case STATUS_NOTIFICATION:
                handleStatusNotification(session, msg);
                break;
            case START_TRANSACTION:
                handleStartTransaction(session, msg);
                break;
            case STOP_TRANSACTION:
                handleStopTransaction(session, msg);
                break;
        }
    }
    
    private void handleHeartbeat(WebSocketSession session, OCPPMessage msg) {
        Long chargerId = getChargerIdFromSession(session);
        protocolService.sendHeartbeat(chargerId);
        
        // 回复OCPP HeartbeatResponse
        sendResponse(session, createHeartbeatResponse());
    }
}
```

#### 步骤3: 消息序列化

```java
public class OCPPMessageParser {
    private final ObjectMapper objectMapper = new ObjectMapper();
    
    public OCPPMessage parseMessage(String payload) {
        // OCPP消息格式: [MessageType, MessageId, Action, Payload]
        JsonNode node = objectMapper.readTree(payload);
        
        int messageType = node.get(0).asInt();
        String messageId = node.get(1).asText();
        String action = node.get(2).asText();
        JsonNode payloadNode = node.get(3);
        
        OCPPMessage message = new OCPPMessage();
        message.setMessageType(messageType);
        message.setMessageId(messageId);
        message.setAction(action);
        message.setPayload(payloadNode);
        
        return message;
    }
}
```

---

## 四、云快充协议对接

### 4.1 云快充概述

- **协议版本**: 云快充 v3.0
- **传输方式**: HTTP REST API
- **消息格式**: JSON

### 4.2 关键API接口

| API接口 | 对应事件 | 说明 |
|--------|---------|------|
| /station/register | - | 充电站注册 |
| /charger/heartbeat | HeartbeatEvent | 心跳上报 |
| /charger/status | StatusEvent | 状态上报 |
| /order/start | StartEvent | 开始充电 |
| /order/stop | StopEvent | 停止充电 |

### 4.3 实现步骤

#### 步骤1: 实现协议接口

```java
@Service
public class CloudChargeProtocolServiceImpl implements ICloudChargeProtocolService {
    private final ProtocolEventPublisher eventPublisher;
    private final RestTemplate restTemplate;
    
    @Override
    public boolean reportHeartbeat(Long chargerId) {
        // 发布心跳事件
        eventPublisher.publishHeartbeat(
            chargerId,
            getTenantId(),
            "CloudCharge",
            LocalDateTime.now()
        );
        return true;
    }
    
    @Override
    public boolean startCharging(Long chargerId, String sessionId, Long userId) {
        // 调用云快充API
        CloudChargeStartRequest request = new CloudChargeStartRequest();
        request.setChargerId(chargerId);
        request.setUserId(userId);
        
        CloudChargeStartResponse response = restTemplate.postForObject(
            cloudChargeUrl + "/order/start",
            request,
            CloudChargeStartResponse.class
        );
        
        // 发布开始充电事件
        eventPublisher.publishChargingStart(
            chargerId,
            getTenantId(),
            "CloudCharge",
            sessionId,
            userId,
            response.getOrderNo(),
            0.0,
            response.isSuccess(),
            response.getMessage()
        );
        
        return response.isSuccess();
    }
}
```

#### 步骤2: REST API控制器

```java
@RestController
@RequestMapping("/api/cloudcharge")
public class CloudChargeController {
    private final ICloudChargeProtocolService protocolService;
    
    /**
     * 接收云快充心跳上报
     */
    @PostMapping("/heartbeat")
    public CloudChargeResponse receiveHeartbeat(@RequestBody CloudChargeHeartbeatRequest request) {
        Long chargerId = request.getChargerId();
        protocolService.reportHeartbeat(chargerId);
        
        return CloudChargeResponse.success("Heartbeat received");
    }
    
    /**
     * 接收云快充状态上报
     */
    @PostMapping("/status")
    public CloudChargeResponse receiveStatus(@RequestBody CloudChargeStatusRequest request) {
        Long chargerId = request.getChargerId();
        Integer status = request.getStatus();
        protocolService.reportStatus(chargerId, status);
        
        return CloudChargeResponse.success("Status received");
    }
}
```

#### 步骤3: 请求签名验证

```java
@Component
public class CloudChargeSignatureValidator {
    
    public boolean validateSignature(CloudChargeRequest request, String signature) {
        // 拼接签名字符串
        String signStr = buildSignString(request);
        
        // 使用密钥计算签名
        String expectedSignature = HmacUtils.hmacSha256Hex(
            apiSecret,
            signStr
        );
        
        // 比对签名
        return signature.equals(expectedSignature);
    }
    
    private String buildSignString(CloudChargeRequest request) {
        // 按字段名排序拼接
        Map<String, Object> params = BeanUtils.beanToMap(request);
        return params.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .map(e -> e.getKey() + "=" + e.getValue())
            .collect(Collectors.joining("&"));
    }
}
```

---

## 五、测试和调试

### 5.1 使用调试工具

```bash
# 1. 模拟心跳
curl -X POST http://localhost:8080/debug/protocol/simulate/heartbeat \
  -H "Content-Type: application/json" \
  -d '{
    "chargerId": 1,
    "tenantId": 1,
    "protocolType": "OCPP"
  }'

# 2. 模拟开始充电
curl -X POST http://localhost:8080/debug/protocol/simulate/start \
  -H "Content-Type: application/json" \
  -d '{
    "chargerId": 1,
    "tenantId": 1,
    "userId": 100,
    "protocolType": "OCPP",
    "initialEnergy": 0.0
  }'

# 3. 查看事件历史
curl http://localhost:8080/debug/protocol/events/history?chargerId=1
```

### 5.2 验证事件流转

1. **发送事件**: 使用调试接口或真实设备发送协议消息
2. **查看RabbitMQ**: 确认消息已发布到队列
3. **检查日志**: 查看消费者处理日志
4. **验证数据**: 检查数据库中订单和充电桩状态是否更新

```bash
# 查看RabbitMQ队列消息数
rabbitmqadmin list queues name messages

# 查看消费者日志
tail -f /var/log/evcs/evcs-order.log | grep "Received charging"
```

### 5.3 OCPP模拟器测试

使用OCPP测试工具（如OCPP Test Tool）：

1. 配置WebSocket连接地址: `ws://localhost:8080/ocpp/{chargerId}`
2. 发送BootNotification消息
3. 发送Heartbeat消息（每30秒）
4. 发送StartTransaction消息
5. 发送MeterValues消息（充电数据）
6. 发送StopTransaction消息

---

## 六、常见问题

### 6.1 消息丢失

**问题**: 协议事件发送后，消费者没有处理

**排查步骤**:
1. 检查RabbitMQ连接是否正常
2. 检查路由键是否正确
3. 检查队列绑定关系
4. 查看RabbitMQ管理界面确认消息是否到达队列

**解决方案**:
```bash
# 检查队列绑定
rabbitmqadmin list bindings

# 查看队列消息
rabbitmqadmin get queue=evcs.protocol.charging count=1
```

### 6.2 消息重复消费

**问题**: 同一事件被处理多次

**原因**: 
- 消费者没有正确手动确认（basicAck）
- 幂等性检查缺失

**解决方案**:
```java
// 确保手动确认
channel.basicAck(deliveryTag, false);

// 添加幂等性检查
if (processedEventIds.contains(event.getEventId())) {
    log.warn("Event already processed: {}", event.getEventId());
    channel.basicAck(deliveryTag, false);
    return;
}
```

### 6.3 租户数据串读

**问题**: 租户A的事件被租户B消费

**原因**: 消费者没有设置租户上下文

**解决方案**:
```java
try {
    // 设置租户上下文
    TenantContext.setCurrentTenantId(event.getTenantId());
    TenantContext.setCurrentUserId(event.getUserId());
    
    // 业务处理
    processEvent(event);
    
} finally {
    // 清理上下文
    TenantContext.clear();
}
```

### 6.4 死信队列消息堆积

**问题**: 死信队列消息数量持续增长

**原因**: 
- 业务异常没有处理
- 数据库连接问题
- 租户上下文缺失

**解决方案**:
1. 查看死信队列消息内容
2. 修复业务代码问题
3. 重新发布消息到业务队列

```bash
# 查看死信消息
rabbitmqadmin get queue=evcs.protocol.dlx.queue count=10

# 重新发布消息（需要开发脚本）
# 从死信队列取出消息，修复问题后重新发布
```

---

## 七、性能优化

### 7.1 并发消费

增加消费者并发数量：

```yaml
spring:
  rabbitmq:
    listener:
      simple:
        concurrency: 5      # 最小并发数
        max-concurrency: 10  # 最大并发数
        prefetch: 20         # 预取数量
```

### 7.2 批量处理

对于高频事件（如心跳），可以批量处理：

```java
@Component
public class BatchHeartbeatProcessor {
    private final List<HeartbeatEvent> buffer = new ArrayList<>();
    
    @Scheduled(fixedDelay = 5000)  // 每5秒处理一次
    public void processBatch() {
        if (buffer.isEmpty()) return;
        
        List<HeartbeatEvent> events = new ArrayList<>(buffer);
        buffer.clear();
        
        // 批量更新数据库
        chargerMapper.batchUpdateHeartbeat(events);
    }
    
    public void addEvent(HeartbeatEvent event) {
        buffer.add(event);
    }
}
```

### 7.3 异步处理

对于非关键业务，使用异步处理：

```java
@Service
public class AsyncChargingProcessor {
    
    @Async("chargingExecutor")
    public void processChargingStart(StartEvent event) {
        // 异步处理充电开始事件
        // 如：发送通知、记录日志等非关键操作
    }
}
```

---

## 八、监控和告警

### 8.1 关键指标

- **消息发布速率**: 每秒发布的事件数量
- **消息消费速率**: 每秒消费的事件数量
- **队列堆积量**: 各队列中待处理的消息数量
- **死信队列消息数**: 处理失败的消息数量
- **消费者延迟**: 消息从发布到消费的时间

### 8.2 Prometheus指标

```java
@Component
public class ProtocolMetrics {
    private final Counter eventPublished = Counter.builder("protocol.event.published")
        .tag("type", "all")
        .register(Metrics.globalRegistry);
    
    private final Counter eventConsumed = Counter.builder("protocol.event.consumed")
        .tag("type", "all")
        .register(Metrics.globalRegistry);
    
    public void recordEventPublished(String eventType) {
        eventPublished.increment();
    }
    
    public void recordEventConsumed(String eventType) {
        eventConsumed.increment();
    }
}
```

### 8.3 告警规则

```yaml
# Prometheus告警规则
groups:
  - name: protocol_alerts
    rules:
      - alert: HighMessageQueueBacklog
        expr: rabbitmq_queue_messages{queue="evcs.protocol.charging"} > 1000
        for: 5m
        annotations:
          summary: "充电事件队列堆积过多"
          
      - alert: DeadLetterQueueGrowing
        expr: rabbitmq_queue_messages{queue="evcs.protocol.dlx.queue"} > 10
        for: 1m
        annotations:
          summary: "死信队列消息增长"
```

---

## 九、安全最佳实践

### 9.1 租户隔离

- 所有事件必须包含 `tenantId`
- 消费者必须设置租户上下文
- 使用try-finally确保上下文清理

### 9.2 消息加密

对于敏感数据，考虑消息加密：

```java
public class EncryptedEventPublisher {
    private final AESEncryptor encryptor;
    
    public void publishEncryptedEvent(ProtocolEvent event) {
        String json = objectMapper.writeValueAsString(event);
        String encrypted = encryptor.encrypt(json);
        
        rabbitTemplate.convertAndSend(
            PROTOCOL_EXCHANGE,
            event.getRoutingKey(),
            encrypted
        );
    }
}
```

### 9.3 访问控制

- 调试接口仅在开发/测试环境启用
- 生产环境禁用事件模拟功能
- 使用Spring Security保护调试端点

```java
@Configuration
@Profile("!prod")  // 非生产环境
public class DebugConfig {
    @Bean
    public ProtocolDebugController protocolDebugController() {
        return new ProtocolDebugController();
    }
}
```

---

## 十、附录

### 10.1 协议接口定义

参考代码：
- `evcs-protocol/src/main/java/com/evcs/protocol/api/IOCPPProtocolService.java`
- `evcs-protocol/src/main/java/com/evcs/protocol/api/ICloudChargeProtocolService.java`

### 10.2 配置示例

```yaml
# application-protocol.yml
evcs:
  protocol:
    ocpp:
      websocket-path: /ocpp/{chargerId}
      heartbeat-interval: 30s
      connection-timeout: 60s
    cloudcharge:
      api-url: https://api.cloudcharge.com
      api-key: ${CLOUDCHARGE_API_KEY}
      api-secret: ${CLOUDCHARGE_API_SECRET}
      signature-algorithm: HmacSHA256
```

---

**维护者**: EVCS Dev Team  
**更新时间**: 2025-10-12
