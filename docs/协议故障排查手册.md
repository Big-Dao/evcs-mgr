# 协议故障排查手册 (Protocol Troubleshooting Manual)

> **English**: Troubleshooting guide for protocol layer issues and solutions  
> **最后更新**: 2025-10-20  
> **维护者**: EVCS DevOps Team  
> **状态**: 已发布  
> **版本**: 1.0  
> **目标读者**: 运维人员、技术支持

## 目录

- [一、概述](#一概述)
- [二、故障分类](#二故障分类)
- [三、连接故障](#三连接故障)
- [四、消息故障](#四消息故障)
- [五、业务故障](#五业务故障)
- [六、性能问题](#六性能问题)
- [七、监控告警](#七监控告警)
- [八、应急响应](#八应急响应)

---

## 一、概述

本手册提供EVCS Manager系统协议层常见故障的排查方法和解决方案。

---

## 二、故障分类

### 2.1 故障级别

| 级别 | 描述 | 响应时间 |
|-----|------|---------|
| P0 | 系统级故障，影响所有充电桩 | 立即响应 |
| P1 | 重要功能故障，影响部分充电桩 | 30分钟内 |
| P2 | 一般功能故障，不影响充电业务 | 2小时内 |
| P3 | 轻微问题，可延后处理 | 1天内 |

### 2.2 故障类型

- **连接故障**: 充电桩无法连接到服务器
- **消息故障**: 消息发送/接收异常
- **业务故障**: 业务逻辑处理错误
- **性能故障**: 响应延迟过高

---

## 三、快速诊断流程

```
┌─────────────┐
│ 发现故障     │
└──────┬──────┘
       ↓
┌─────────────┐
│ 收集日志     │ ← tail -f /var/log/evcs/*.log
└──────┬──────┘
       ↓
┌─────────────┐
│ 检查服务状态  │ ← systemctl status evcs-*
└──────┬──────┘
       ↓
┌─────────────┐
│ 检查RabbitMQ │ ← rabbitmqctl status
└──────┬──────┘
       ↓
┌─────────────┐
│ 检查数据库   │ ← psql连接测试
└──────┬──────┘
       ↓
┌─────────────┐
│ 分析问题根因 │
└──────┬──────┘
       ↓
┌─────────────┐
│ 实施修复方案 │
└──────┬──────┘
       ↓
┌─────────────┐
│ 验证修复结果 │
└─────────────┘
```

---

## 四、常见故障排查

### 4.1 充电桩无法连接

#### 症状
- 充电桩显示离线
- WebSocket连接失败
- 日志显示连接超时

#### 排查步骤

**1. 检查网络连通性**
```bash
# 测试充电桩到服务器的网络
ping [服务器IP]

# 测试端口连通性
telnet [服务器IP] 8080

# 检查防火墙规则
sudo iptables -L -n | grep 8080
```

**2. 检查服务状态**
```bash
# 检查EVCS服务
systemctl status evcs-protocol

# 检查WebSocket端点
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Key: test" \
  -H "Sec-WebSocket-Version: 13" \
  http://localhost:8080/ocpp/charger001
```

**3. 检查日志**
```bash
# 查看协议服务日志
tail -f /var/log/evcs/evcs-protocol.log | grep -i "connect\|disconnect"

# 查看Nginx/网关日志
tail -f /var/log/nginx/access.log | grep ocpp
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 端口未开放 | 开放防火墙端口: `sudo ufw allow 8080` |
| 服务未启动 | 启动服务: `systemctl start evcs-protocol` |
| 连接数超限 | 增加连接池大小，重启服务 |
| SSL证书过期 | 更新SSL证书 |

---

### 4.2 心跳超时

#### 症状
- 充电桩状态显示离线
- 日志显示"Heartbeat timeout"
- 最后心跳时间超过5分钟

#### 排查步骤

**1. 检查心跳配置**
```bash
# 查看心跳间隔配置
grep -r "heartbeat" /etc/evcs/application.yml

# 查看数据库中的最后心跳时间
psql -U evcs -d evcs_db -c "
  SELECT id, charger_code, status, last_heartbeat 
  FROM charger 
  WHERE last_heartbeat < NOW() - INTERVAL '5 minutes'
  ORDER BY last_heartbeat DESC 
  LIMIT 10;
"
```

**2. 检查RabbitMQ队列**
```bash
# 查看心跳队列消息堆积
rabbitmqadmin list queues name messages | grep heartbeat

# 查看心跳队列消费者
rabbitmqadmin list consumers queue vhost channel consumer_tag
```

**3. 检查消费者日志**
```bash
# 查看心跳事件处理日志
tail -f /var/log/evcs/evcs-station.log | grep "Heartbeat"

# 统计心跳事件处理频率
tail -1000 /var/log/evcs/evcs-station.log | grep "Received heartbeat" | wc -l
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 消费者处理慢 | 增加并发消费者数量 |
| 队列堆积 | 临时清理队列: `rabbitmqadmin purge queue name=evcs.protocol.heartbeat` |
| 数据库连接超时 | 检查数据库连接池配置 |
| 充电桩配置错误 | 调整充电桩心跳间隔 |

---

### 4.3 消息丢失

#### 症状
- 充电桩发送了事件但系统没有记录
- 订单没有创建
- 充电桩状态没有更新

#### 排查步骤

**1. 检查消息发布**
```bash
# 查看发布日志
tail -f /var/log/evcs/evcs-protocol.log | grep "Publishing protocol event"

# 检查RabbitMQ连接
rabbitmqctl list_connections name peer_host state
```

**2. 检查路由键**
```bash
# 查看绑定关系
rabbitmqadmin list bindings source destination routing_key

# 验证路由键格式
# 心跳: protocol.heartbeat.OCPP
# 状态: protocol.status.CloudCharge
# 充电: protocol.charging.start / protocol.charging.stop
```

**3. 检查消息是否到达队列**
```bash
# 查看队列消息数
rabbitmqadmin list queues name messages messages_ready messages_unacknowledged

# 获取队列中的消息示例
rabbitmqadmin get queue=evcs.protocol.charging count=1
```

**4. 检查消费者**
```bash
# 查看消费者状态
rabbitmqadmin list consumers queue channel state

# 查看消费日志
tail -f /var/log/evcs/evcs-order.log | grep "Received charging"
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 路由键错误 | 修正路由键格式，重新发布事件 |
| 队列绑定错误 | 重新绑定队列: 参考 `RabbitMQConfig.java` |
| 消费者未启动 | 启动服务: `systemctl start evcs-order` |
| 消息未持久化 | 检查RabbitMQ配置，启用持久化 |

---

### 4.4 订单重复创建

#### 症状
- 同一个sessionId创建了多个订单
- 日志显示"Order already exists"告警
- 用户被重复扣费

#### 排查步骤

**1. 检查幂等性实现**
```bash
# 查看订单创建日志
grep "sessionId=" /var/log/evcs/evcs-order.log | grep "Charging order created"

# 查询重复订单
psql -U evcs -d evcs_db -c "
  SELECT session_id, COUNT(*) as count
  FROM charging_order
  GROUP BY session_id
  HAVING COUNT(*) > 1;
"
```

**2. 检查消息确认**
```bash
# 查看未确认消息
rabbitmqadmin list queues name messages_unacknowledged | grep charging

# 查看消费日志中的ack/nack
tail -f /var/log/evcs/evcs-order.log | grep -E "basicAck|basicNack"
```

**3. 检查事件ID去重**
```bash
# 查看事件ID重复情况
grep "Event already processed" /var/log/evcs/evcs-order.log | wc -l
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 幂等性检查缺失 | 添加sessionId唯一性约束，代码实现幂等性 |
| 消息未确认 | 确保消费者正确调用 `basicAck` |
| 并发竞争 | 使用分布式锁（Redis）或数据库锁 |
| 重复消息 | 增强事件ID去重逻辑 |

---

### 4.5 租户数据串读

#### 症状
- 租户A能看到租户B的订单
- 充电桩状态更新到错误的租户
- 日志显示"TenantContextMissingException"

#### 排查步骤

**1. 检查租户上下文**
```bash
# 查看租户上下文相关日志
tail -f /var/log/evcs/evcs-order.log | grep -E "TenantContext|tenantId"

# 查看租户上下文异常
grep "TenantContextMissingException" /var/log/evcs/*.log
```

**2. 检查数据库隔离**
```bash
# 验证tenant_id过滤
psql -U evcs -d evcs_db -c "
  SELECT tenant_id, COUNT(*) 
  FROM charging_order 
  GROUP BY tenant_id;
"

# 检查跨租户查询
# 应该没有结果或抛出异常
psql -U evcs -d evcs_db -c "
  SELECT * FROM charging_order 
  WHERE tenant_id != [当前租户ID]
  LIMIT 1;
"
```

**3. 检查事件租户ID**
```bash
# 查看事件中的tenantId
rabbitmqadmin get queue=evcs.protocol.charging count=1 | grep tenantId
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 租户上下文未设置 | 消费者中添加 `TenantContext.setCurrentTenantId(event.getTenantId())` |
| 租户上下文未清理 | 使用try-finally确保清理: `TenantContext.clear()` |
| 事件未包含tenantId | 协议适配器发布事件时必须设置tenantId |
| MyBatis Plus过滤失效 | 检查 `CustomTenantLineHandler` 配置 |

---

### 4.6 性能问题

#### 症状
- 接口响应时间超过2秒
- 消息队列堆积严重
- CPU/内存使用率过高

#### 排查步骤

**1. 检查系统资源**
```bash
# 查看CPU使用率
top -bn1 | grep evcs

# 查看内存使用
free -h
ps aux --sort=-%mem | head -n 10

# 查看网络连接数
netstat -an | grep :8080 | wc -l
```

**2. 检查队列堆积**
```bash
# 查看所有队列消息数
rabbitmqadmin list queues name messages | sort -k2 -n -r

# 查看消费速率
rabbitmqctl list_queues name messages_ready messages_unacknowledged consumers
```

**3. 检查慢查询**
```bash
# PostgreSQL慢查询日志
tail -f /var/log/postgresql/postgresql-*.log | grep "duration.*ms"

# 查询执行计划
psql -U evcs -d evcs_db -c "EXPLAIN ANALYZE SELECT * FROM charging_order WHERE status = 1;"
```

**4. 分析应用日志**
```bash
# 统计接口响应时间
grep "duration=" /var/log/evcs/evcs-order.log | \
  awk -F'duration=' '{print $2}' | \
  awk '{print $1}' | \
  sort -n | \
  tail -n 100

# 查找慢接口
grep "duration=" /var/log/evcs/evcs-order.log | \
  awk -F'duration=' '{if($2 > 1000) print}' | \
  tail -n 50
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 队列堆积 | 增加消费者并发数，优化消费者性能 |
| 数据库慢查询 | 添加索引，优化SQL |
| 内存不足 | 增加JVM堆内存: `-Xmx4g` |
| 连接池耗尽 | 增加数据库连接池大小 |

---

### 4.7 死信队列消息堆积

#### 症状
- 死信队列消息数量持续增长
- 业务功能异常
- 日志显示重复错误

#### 排查步骤

**1. 查看死信消息**
```bash
# 获取死信消息
rabbitmqadmin get queue=evcs.protocol.dlx.queue count=10

# 查看死信原因
rabbitmqadmin get queue=evcs.protocol.dlx.queue count=1 | grep "x-death"
```

**2. 分析错误日志**
```bash
# 查找处理失败的日志
grep "Failed to process" /var/log/evcs/*.log | tail -n 50

# 按错误类型分组统计
grep "Failed to process" /var/log/evcs/*.log | \
  awk -F': ' '{print $NF}' | \
  sort | uniq -c | sort -rn
```

**3. 检查业务数据**
```bash
# 检查是否有脏数据
psql -U evcs -d evcs_db -c "
  SELECT * FROM charging_order 
  WHERE status IS NULL 
  OR charger_id NOT IN (SELECT id FROM charger)
  LIMIT 10;
"
```

#### 解决方案

| 问题 | 解决方法 |
|-----|---------|
| 业务异常 | 修复业务代码bug，重启服务 |
| 数据完整性问题 | 清理脏数据，修复外键约束 |
| 租户上下文缺失 | 确保事件包含tenantId，消费者正确设置上下文 |
| 消息格式错误 | 修正消息格式，重新发布 |

**重新处理死信消息**:
```python
# 示例脚本: 从死信队列取出消息并重新发布
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

# 从死信队列获取消息
method, properties, body = channel.basic_get('evcs.protocol.dlx.queue')

if method:
    # 修复消息（如果需要）
    fixed_body = fix_message(body)
    
    # 重新发布到业务队列
    channel.basic_publish(
        exchange='evcs.protocol.events',
        routing_key='protocol.charging.start',
        body=fixed_body
    )
    
    # 确认死信消息
    channel.basic_ack(method.delivery_tag)
```

---

## 五、日志分析

### 5.1 日志位置

| 服务 | 日志路径 |
|-----|---------|
| 协议服务 | `/var/log/evcs/evcs-protocol.log` |
| 订单服务 | `/var/log/evcs/evcs-order.log` |
| 充电桩服务 | `/var/log/evcs/evcs-station.log` |
| RabbitMQ | `/var/log/rabbitmq/rabbit@[hostname].log` |
| PostgreSQL | `/var/log/postgresql/postgresql-*.log` |

### 5.2 关键日志关键词

```bash
# 连接相关
grep -E "connect|disconnect|connection|session" /var/log/evcs/*.log

# 事件发布
grep "Publishing protocol event" /var/log/evcs/evcs-protocol.log

# 事件消费
grep "Received.*event" /var/log/evcs/evcs-order.log

# 错误和异常
grep -E "ERROR|Exception|Failed" /var/log/evcs/*.log

# 性能问题
grep "duration=" /var/log/evcs/*.log | grep -E "[0-9]{4,}"
```

### 5.3 日志级别调整

临时调整日志级别以获取更多调试信息：

```bash
# 修改logback配置
vi /etc/evcs/logback-spring.xml

# 将特定包的日志级别改为DEBUG
<logger name="com.evcs.protocol" level="DEBUG"/>
<logger name="com.evcs.order.mq" level="DEBUG"/>

# 重启服务生效
systemctl restart evcs-protocol
systemctl restart evcs-order
```

---

## 六、监控和告警

### 6.1 关键指标

| 指标 | 正常范围 | 告警阈值 |
|-----|---------|---------|
| 心跳队列消息数 | < 100 | > 1000 |
| 充电队列消息数 | < 50 | > 500 |
| 死信队列消息数 | 0 | > 10 |
| 接口P99响应时间 | < 500ms | > 2000ms |
| 消费者延迟 | < 1s | > 10s |
| 充电桩在线率 | > 95% | < 90% |

### 6.2 Prometheus查询

```promql
# 队列堆积量
rabbitmq_queue_messages{queue="evcs.protocol.charging"}

# 消息发布速率
rate(protocol_event_published_total[5m])

# 消息消费速率
rate(protocol_event_consumed_total[5m])

# 接口响应时间P99
histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))
```

### 6.3 告警通知

配置Alertmanager发送告警到企业微信/钉钉/邮件：

```yaml
# alertmanager.yml
route:
  receiver: 'default'
  group_by: ['alertname']
  
receivers:
  - name: 'default'
    webhook_configs:
      - url: 'http://alert-gateway:8080/webhook'
```

---

## 七、应急处理

### 7.1 服务降级

当系统负载过高时，可以临时降级某些功能：

```bash
# 1. 暂停心跳事件处理（仅保留关键业务）
rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app

# 2. 增加消费者数量
# 编辑 application.yml
spring.rabbitmq.listener.simple.max-concurrency: 20

# 3. 重启服务
systemctl restart evcs-order
```

### 7.2 数据恢复

如果数据库出现问题，使用备份恢复：

```bash
# 1. 停止服务
systemctl stop evcs-*

# 2. 恢复数据库备份
pg_restore -U evcs -d evcs_db /backup/evcs_db_20251012.dump

# 3. 重新处理队列消息
rabbitmqadmin get queue=evcs.protocol.charging count=100 > /tmp/messages.json

# 4. 启动服务
systemctl start evcs-*
```

### 7.3 紧急联系方式

| 角色 | 联系方式 | 工作时间 |
|-----|---------|---------|
| 值班工程师 | 138xxxx1234 | 7×24小时 |
| 技术负责人 | 139xxxx5678 | 工作日 9-18点 |
| 系统架构师 | 186xxxx9012 | 紧急情况 |

---

## 八、预防措施

### 8.1 监控检查清单

- [ ] 每日检查队列堆积情况
- [ ] 每日检查死信队列消息数
- [ ] 每周查看慢查询日志
- [ ] 每月进行性能测试
- [ ] 每月备份数据库

### 8.2 定期维护

```bash
# 每周执行
# 1. 清理过期日志
find /var/log/evcs -name "*.log.*" -mtime +7 -delete

# 2. 清理死信队列已处理的消息
rabbitmqadmin delete queue name=evcs.protocol.dlx.queue.processed

# 3. 数据库vacuum
psql -U evcs -d evcs_db -c "VACUUM ANALYZE charging_order;"

# 4. 重启服务（非高峰时段）
systemctl restart evcs-protocol
systemctl restart evcs-order
systemctl restart evcs-station
```

---

## 九、附录

### 9.1 常用命令速查

```bash
# RabbitMQ管理
rabbitmqctl status                    # 状态检查
rabbitmqctl list_queues              # 列出所有队列
rabbitmqctl list_connections         # 列出所有连接
rabbitmqctl list_consumers           # 列出所有消费者

# PostgreSQL管理
psql -U evcs -d evcs_db              # 连接数据库
\dt                                  # 列出所有表
\d+ charging_order                   # 查看表结构

# 服务管理
systemctl status evcs-protocol       # 查看服务状态
systemctl restart evcs-protocol      # 重启服务
journalctl -u evcs-protocol -f       # 查看服务日志
```

### 9.2 配置文件位置

| 配置文件 | 路径 |
|---------|------|
| 应用配置 | `/etc/evcs/application.yml` |
| 日志配置 | `/etc/evcs/logback-spring.xml` |
| RabbitMQ配置 | `/etc/rabbitmq/rabbitmq.conf` |
| PostgreSQL配置 | `/etc/postgresql/*/main/postgresql.conf` |

---

**维护者**: EVCS Operations Team  
**更新时间**: 2025-10-12  
**紧急联系**: ops@evcs.com
