# EVCS Manager 下一步工作规划（2025年10月）

> **规划日期**: 2025-10-11  
> **当前状态**: M7完成（监控体系建立）  
> **规划周期**: 剩余5周（第1、2、4、5、6、8周）

---

## 一、当前进度概览 📊

### ✅ 已完成里程碑

#### M0-M2: 基础架构（P0/P1）
- ✅ 多租户四层隔离架构
- ✅ 分时计费系统（TOU）
- ✅ 订单管理完整闭环
- ✅ 充电站与充电桩管理
- ✅ Prometheus指标暴露

#### M3: 支付集成
- ✅ 支付宝集成（APP + 扫码）
- ✅ 微信支付集成（小程序 + Native）
- ✅ 支付对账功能
- ✅ 集成测试套件

#### M6: 质量提升
- ✅ 集成测试框架
- ✅ 多租户隔离测试
- ✅ 代码质量改进

#### M7: 监控体系（刚完成！）
- ✅ JSON格式日志 + 敏感信息脱敏
- ✅ Prometheus业务指标框架
- ✅ Grafana Dashboard（系统 + 业务）
- ✅ Resilience4j熔断限流
- ✅ ELK日志收集配置

### ⏳ 待完成任务（P3阶段剩余工作）

#### 第1周：环境修复与安全加固 🔴
- 当前Java版本: **17** ❌ 目标: **21**
- Gradle Wrapper JAR: ✅ 已存在
- JWT安全漏洞: ⚠️ 待修复
- 租户上下文清理: ⚠️ 待完善
- 异常处理顺序: ⚠️ 待修复

#### 第2周：协议事件流对接 🟠
- 协议事件模型: ✅ 基础完成（ProtocolEvent基类存在）
- RabbitMQ集成: ⏳ 配置类存在，需完善
- 协议适配器: ⏳ 接口定义完成，需实现
- 协议调试工具: ✅ ProtocolDebugController已创建

#### 第4周：性能优化 🟡
- Redis缓存: ⏳ 待实现
- 对账优化: ⏳ 待实现分页
- 数据库索引: ⏳ 待优化
- 性能压测: ⏳ 待执行

#### 第5周：前端开发 🟢
- 前端框架: ✅ evcs-admin目录存在（Vue 3）
- 管理界面: ✅ 基础结构完成
- 功能完善: ⏳ 待补充

#### 第6周：代码质量 🟢
- 租户过滤优化: ⏳ 待清理手动过滤
- JSON处理优化: ⏳ 待用Jackson替代手动拼接
- TODO清理: ⏳ 9个TODO待实现

#### 第8周：测试发布 🔴
- 单元测试覆盖率: ~40% → 目标80%
- 集成测试: ⏳ 待补充
- 文档完善: ⏳ 待更新
- 发布准备: ⏳ 待规划

---

## 二、紧急优先级任务（按时间顺序）

### 🔥 第1周：环境修复与安全加固（立即开始）

**为什么最重要**: 
- Java版本不匹配会导致构建问题
- 安全漏洞可能导致数据泄露（高风险）
- 租户上下文泄漏可能造成数据串读（严重后果）

**核心任务清单**:

#### 任务1: Java版本统一到21 ✅ 优先级P0
**现状**: 当前使用Java 17，项目配置要求Java 21  
**影响**: 某些Java 21特性无法使用，构建环境不一致

**操作步骤**:
1. 更新本地开发环境到Java 21
2. 更新CI/CD配置（`.github/workflows/*.yml`）
3. 更新Docker基础镜像（`FROM eclipse-temurin:21-jre-jammy`）
4. 验证构建: `./gradlew clean build`

**预计时间**: 1-2小时  
**验收标准**: 所有环境Java版本统一为21，构建通过

---

#### 任务2: 修复JWT白名单路径遍历漏洞 🔴 优先级P0
**现状**: `JwtAuthGlobalFilter` 使用 `startsWith()` 匹配白名单  
**风险**: 攻击者可能通过 `/auth/login/../admin/users` 绕过验证

**修复方案**:
```java
// 文件位置: evcs-gateway/src/main/java/com/evcs/gateway/filter/JwtAuthGlobalFilter.java

// 方法1: 使用PathMatcher（推荐）
private final PathMatcher pathMatcher = new AntPathMatcher();

private boolean isWhitelisted(String path) {
    // 先规范化路径，防止 ../ 绕过
    String normalizedPath = pathMatcher.combine("/", path);
    
    return WHITE_LIST.stream()
        .anyMatch(pattern -> pathMatcher.match(pattern, normalizedPath));
}

// 方法2: 路径规范化 + 精确匹配
private String normalizePath(String path) {
    try {
        return Paths.get(path).normalize().toString();
    } catch (Exception e) {
        return path;
    }
}
```

**测试用例**:
```java
@Test
void testPathTraversalAttack() {
    // 应该被拒绝
    assertFalse(isWhitelisted("/auth/login/../admin/users"));
    assertFalse(isWhitelisted("/auth/../admin/users"));
    
    // 应该被允许
    assertTrue(isWhitelisted("/auth/login"));
    assertTrue(isWhitelisted("/auth/register"));
}
```

**预计时间**: 3-4小时  
**验收标准**: 路径遍历攻击测试全部通过

---

#### 任务3: 租户上下文异常处理增强 🔴 优先级P0
**现状**: `TenantContext.getCurrentTenantId()` 返回null时返回-1  
**问题**: -1可能被当作有效租户ID，难以追踪问题

**修复方案**:
```java
// 文件位置: evcs-common/src/main/java/com/evcs/common/context/TenantContext.java

public static Long getCurrentTenantId() {
    Long tenantId = TENANT_ID.get();
    if (tenantId == null) {
        throw new TenantContextMissingException(
            "租户上下文缺失，请检查请求是否携带租户信息");
    }
    return tenantId;
}

// 提供可选的获取方法（不抛异常）
public static Optional<Long> getTenantIdOptional() {
    return Optional.ofNullable(TENANT_ID.get());
}
```

**异常处理器**:
```java
// 文件位置: evcs-common/src/main/java/com/evcs/common/exception/GlobalExceptionHandler.java

@ExceptionHandler(TenantContextMissingException.class)
public ResponseEntity<Result<?>> handleTenantContextMissing(
        TenantContextMissingException e) {
    log.error("租户上下文缺失: {}", e.getMessage());
    return ResponseEntity.status(HttpStatus.FORBIDDEN)
        .body(Result.error(403, "租户上下文缺失，访问被拒绝"));
}
```

**预计时间**: 2小时  
**验收标准**: 租户上下文缺失时抛出明确异常，日志可追踪

---

#### 任务4: 完善TenantContext清理机制 🟡 优先级P1
**现状**: ThreadLocal可能在线程池场景泄漏  
**风险**: 租户数据串读，严重安全问题

**修复方案**:
```java
// 文件位置: evcs-gateway/src/main/java/com/evcs/gateway/filter/TenantInterceptor.java

@Override
public boolean preHandle(HttpServletRequest request, 
                        HttpServletResponse response, 
                        Object handler) throws Exception {
    try {
        // 设置租户上下文
        Long tenantId = extractTenantId(request);
        TenantContext.setCurrentTenantId(tenantId);
        return true;
    } catch (Exception e) {
        log.error("租户上下文初始化失败", e);
        throw e;
    }
}

@Override
public void afterCompletion(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler, 
                           Exception ex) throws Exception {
    // 确保清理上下文
    try {
        TenantContext.clear();
    } catch (Exception e) {
        log.error("租户上下文清理失败", e);
    }
}
```

**考虑使用 TransmittableThreadLocal**:
```java
// 添加依赖: implementation 'com.alibaba:transmittable-thread-local:2.14.5'

private static final TransmittableThreadLocal<Long> TENANT_ID = 
    new TransmittableThreadLocal<>();
```

**并发测试**:
```java
@Test
void testConcurrentTenantIsolation() throws Exception {
    int threadCount = 100;
    int requestPerThread = 100;
    
    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    
    for (int i = 0; i < threadCount; i++) {
        final long tenantId = i;
        executor.submit(() -> {
            for (int j = 0; j < requestPerThread; j++) {
                TenantContext.setCurrentTenantId(tenantId);
                try {
                    assertEquals(tenantId, TenantContext.getCurrentTenantId());
                } finally {
                    TenantContext.clear();
                }
            }
        });
    }
    
    executor.shutdown();
    executor.awaitTermination(1, TimeUnit.MINUTES);
}
```

**预计时间**: 4-5小时  
**验收标准**: 10000次并发请求无租户数据串读

---

#### 任务5: 修复GlobalExceptionHandler顺序冲突 🟡 优先级P2
**现状**: 多个 `RuntimeException` 处理器可能冲突  
**问题**: 异常处理不可预测，返回错误的HTTP状态码

**修复方案**:
```java
// 文件位置: evcs-common/src/main/java/com/evcs/common/exception/GlobalExceptionHandler.java

// 移除冗余的通用RuntimeException处理器
// @ExceptionHandler(RuntimeException.class) <- 删除

// 保留具体的异常处理器
@ExceptionHandler(TenantContextMissingException.class)
@Order(1)
public ResponseEntity<?> handleTenantContextMissing(...) { ... }

@ExceptionHandler(BusinessException.class)
@Order(2)
public ResponseEntity<?> handleBusinessException(...) { ... }

@ExceptionHandler(MethodArgumentNotValidException.class)
@Order(3)
public ResponseEntity<?> handleValidationException(...) { ... }

// 最后才是通用Exception处理器
@ExceptionHandler(Exception.class)
@Order(100)
public ResponseEntity<?> handleException(...) { ... }
```

**预计时间**: 2小时  
**验收标准**: 不同异常返回正确的HTTP状态码

---

**第1周总结**:
- 总工作量: 约14小时
- 验收标准: 
  - ✅ 构建在干净环境通过
  - ✅ 安全扫描无高危漏洞
  - ✅ 并发测试通过
  - ✅ 所有单元测试通过

---

### 🟠 第2周：协议事件流对接（第1周完成后）

**为什么重要**: 
- 充电桩实时通信的核心功能
- 影响订单创建和状态更新
- RabbitMQ消息队列是系统解耦的关键

**核心任务清单**:

#### 任务1: 完善协议事件模型 📋 优先级P1
**现状**: `ProtocolEvent` 基类已存在，但具体事件类需要完善

**实现计划**:
```java
// 已存在: evcs-protocol/src/main/java/com/evcs/protocol/event/ProtocolEvent.java

// 需要完善的事件类:
1. HeartbeatEvent - 心跳事件 ✅
2. StatusChangeEvent - 状态变更事件 ✅
3. ChargingStartEvent - 开始充电事件 ✅
4. ChargingStopEvent - 停止充电事件 ✅
5. ErrorEvent - 错误事件 ⏳
```

**事件路由键设计**:
```java
public String getRoutingKey() {
    return String.format("evcs.protocol.%s.%s", 
        protocolType.toLowerCase(),    // ocpp / cloudcharge
        eventType.toString().toLowerCase());  // heartbeat / status / start / stop
}

// 示例:
// evcs.protocol.ocpp.heartbeat
// evcs.protocol.cloudcharge.status
// evcs.protocol.ocpp.start
```

**预计时间**: 4小时  
**验收标准**: 所有事件类型定义完整，路由键设计合理

---

#### 任务2: RabbitMQ消息队列集成 📬 优先级P1
**现状**: `RabbitMQConfig` 和 `ProtocolEventPublisher` 已存在

**配置完善**:
```yaml
# application.yml
spring:
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:admin}
    password: ${RABBITMQ_PASSWORD:admin123}
    virtual-host: /evcs
    
    # 发布者确认
    publisher-confirm-type: correlated
    publisher-returns: true
    
    # 消费者配置
    listener:
      simple:
        acknowledge-mode: manual  # 手动确认
        prefetch: 10  # 预取数量
        retry:
          enabled: true
          max-attempts: 3
```

**Queue绑定关系**:
```java
// Exchange: evcs.protocol.events (Topic类型)
// ├─ Queue: evcs.protocol.heartbeat
// │  └─ Binding: evcs.protocol.*.heartbeat
// ├─ Queue: evcs.protocol.charging
// │  └─ Binding: evcs.protocol.*.start
// │  └─ Binding: evcs.protocol.*.stop
// ├─ Queue: evcs.protocol.status
// │  └─ Binding: evcs.protocol.*.status
// └─ Queue: evcs.protocol.error
//    └─ Binding: evcs.protocol.*.error
```

**死信队列配置**:
```java
@Bean
public Queue deadLetterQueue() {
    return QueueBuilder.durable("evcs.protocol.dlq")
        .withArgument("x-message-ttl", 86400000)  // 24小时
        .build();
}
```

**预计时间**: 6小时  
**验收标准**: 消息发送成功率100%，手动ack机制正常

---

#### 任务3: 协议适配器实现 🔌 优先级P1
**现状**: `IOCPPProtocolService` 和 `ICloudChargeProtocolService` 接口已定义

**OCPP协议适配器**:
```java
// 实现: evcs-protocol/src/main/java/com/evcs/protocol/service/OCPPProtocolServiceImpl.java

@Service
public class OCPPProtocolServiceImpl implements IOCPPProtocolService {
    
    private final ProtocolEventPublisher eventPublisher;
    
    @Override
    public void handleHeartbeat(Long chargerId, LocalDateTime heartbeatTime) {
        // 解析OCPP心跳报文
        // 转换为HeartbeatEvent
        // 发布到RabbitMQ
        eventPublisher.publishHeartbeat(chargerId, tenantId, "OCPP", heartbeatTime);
    }
    
    @Override
    public void handleStatusNotification(Long chargerId, String status) {
        // 解析OCPP状态通知
        // 转换为StatusChangeEvent
        eventPublisher.publishStatusChange(chargerId, tenantId, "OCPP", oldStatus, newStatus, statusDesc);
    }
    
    // 实现其他方法...
}
```

**云快充协议适配器**:
```java
// 实现: evcs-protocol/src/main/java/com/evcs/protocol/service/CloudChargeProtocolServiceImpl.java

@Service
public class CloudChargeProtocolServiceImpl implements ICloudChargeProtocolService {
    // 类似OCPP实现，但处理云快充协议格式
}
```

**预计时间**: 8小时  
**验收标准**: 两种协议都能正常接收和转换事件

---

#### 任务4: 消息消费者实现 📥 优先级P1
**实现位置**: 各业务服务中

**订单服务消费者**:
```java
// evcs-order/src/main/java/com/evcs/order/listener/ChargingEventListener.java

@Component
@RabbitListener(queues = "evcs.protocol.charging")
public class ChargingEventListener {
    
    private final OrderService orderService;
    
    @RabbitHandler
    public void handleChargingStart(ChargingStartEvent event, 
                                    Channel channel, 
                                    Message message) {
        try {
            // 幂等性检查
            if (orderService.existsBySessionId(event.getSessionId())) {
                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
                return;
            }
            
            // 创建订单
            orderService.createOrderByProtocolEvent(event);
            
            // 手动确认
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
            
        } catch (Exception e) {
            log.error("处理充电开始事件失败", e);
            // 重新入队（最多3次）
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);
        }
    }
}
```

**预计时间**: 6小时  
**验收标准**: 消息消费成功率≥99%，幂等性保证

---

#### 任务5: 协议调试工具完善 🔧 优先级P2
**现状**: `ProtocolDebugController` 已存在

**增强功能**:
```java
// evcs-protocol/src/main/java/com/evcs/protocol/controller/ProtocolDebugController.java

@RestController
@RequestMapping("/debug/protocol")
public class ProtocolDebugController {
    
    // 新增：模拟协议事件
    @PostMapping("/simulate")
    public Result<?> simulateEvent(@RequestBody SimulateEventRequest request) {
        // 模拟发送OCPP或云快充事件
        // 用于测试事件流转
    }
    
    // 新增：查看事件历史
    @GetMapping("/events/history")
    public Result<?> getEventHistory(
            @RequestParam Long chargerId,
            @RequestParam(required = false) String eventType,
            @RequestParam(defaultValue = "1") int page,
            @RequestParam(defaultValue = "20") int size) {
        // 查询RabbitMQ或数据库中的事件记录
    }
    
    // 新增：实时事件监控（WebSocket）
    @MessageMapping("/protocol/subscribe")
    public void subscribeEvents(Long chargerId) {
        // WebSocket推送实时事件
    }
}
```

**预计时间**: 4小时  
**验收标准**: 协议调试界面可用，方便联调

---

#### 任务6: 压力测试 ⚡ 优先级P1
**目标**: 1000 TPS

**JMeter脚本**:
```xml
<!-- protocol-stress-test.jmx -->
<ThreadGroup>
    <numThreads>100</numThreads>
    <rampUp>10</rampUp>
    <loops>-1</loops>  <!-- 持续压测 -->
    
    <HTTPSampler>
        <path>/protocol/ocpp/heartbeat</path>
        <method>POST</method>
    </HTTPSampler>
</ThreadGroup>
```

**监控指标**:
- RabbitMQ消息堆积量
- 消费者处理速度
- 数据库写入QPS
- 服务CPU/内存使用率

**预计时间**: 6小时  
**验收标准**: 1000 TPS压测通过，无消息丢失

---

**第2周总结**:
- 总工作量: 约34小时
- 验收标准:
  - ✅ 协议事件端到端流转
  - ✅ 无消息丢失
  - ✅ 压测达到1000 TPS
  - ✅ 协议对接文档完成

---

### 🟡 第4周：分布式缓存与性能优化

**为什么重要**:
- 计费计划频繁查询，需要缓存
- 多实例部署需要缓存一致性
- 对账服务处理大量数据，需要优化

**核心任务清单**:

#### 任务1: Redis分布式缓存 🚀 优先级P1
**缓存键设计**:
```java
// 计费计划缓存
billing:plan:{stationId}:{planId}  // 特定计费计划
billing:plan:default:{stationId}   // 默认计费计划
```

**缓存服务实现**:
```java
@Service
public class BillingPlanCacheService {
    
    private final RedisTemplate<String, BillingPlan> redisTemplate;
    private final BillingPlanService billingPlanService;
    
    public BillingPlan getByStationAndId(Long stationId, Long planId) {
        String key = String.format("billing:plan:%d:%d", stationId, planId);
        
        // 尝试从缓存获取
        BillingPlan plan = redisTemplate.opsForValue().get(key);
        if (plan != null) {
            return plan;
        }
        
        // 缓存未命中，从数据库加载
        plan = billingPlanService.getById(planId);
        if (plan != null && plan.getStationId().equals(stationId)) {
            // 写入缓存，TTL=1小时
            redisTemplate.opsForValue().set(key, plan, 1, TimeUnit.HOURS);
        }
        
        return plan;
    }
}
```

**预计时间**: 6小时  
**验收标准**: 缓存命中率≥80%

---

#### 任务2: Redis Pub/Sub广播 📡 优先级P1
**场景**: 管理员修改计费计划，需要通知所有实例清理缓存

**广播实现**:
```java
// 发布者（计费计划更新时）
@Service
public class BillingPlanService {
    
    private final RedisTemplate<String, String> redisTemplate;
    
    public void updatePlan(BillingPlan plan) {
        // 更新数据库
        billingPlanMapper.updateById(plan);
        
        // 发布广播消息
        String message = String.format("billing:plan:update:%d:%d", 
            plan.getStationId(), plan.getId());
        redisTemplate.convertAndSend("billing:plan:update", message);
    }
}

// 订阅者（各实例监听）
@Component
public class BillingPlanCacheInvalidator implements MessageListener {
    
    private final RedisTemplate<String, BillingPlan> redisTemplate;
    
    @Override
    public void onMessage(Message message, byte[] pattern) {
        String msg = new String(message.getBody());
        // 解析消息: billing:plan:update:stationId:planId
        String[] parts = msg.split(":");
        Long stationId = Long.parseLong(parts[3]);
        Long planId = Long.parseLong(parts[4]);
        
        // 清理本地缓存
        String key = String.format("billing:plan:%d:%d", stationId, planId);
        redisTemplate.delete(key);
    }
}
```

**预计时间**: 6小时  
**验收标准**: 多实例缓存一致性测试通过

---

#### 任务3: 对账服务优化 🔧 优先级P1
**现状**: `ReconciliationService.runDaily()` 一次性加载所有订单，可能OOM

**分页优化**:
```java
@Service
public class ReconciliationServiceImpl {
    
    public ReconcileResult runDaily(LocalDate date) {
        int pageSize = 1000;
        int pageNum = 1;
        int totalProcessed = 0;
        
        while (true) {
            // 分页查询订单
            Page<ChargingOrder> page = orderMapper.selectPage(
                new Page<>(pageNum, pageSize),
                new QueryWrapper<ChargingOrder>()
                    .between("start_time", date.atStartOfDay(), date.atTime(23, 59, 59))
                    .eq("status", OrderStatus.COMPLETED.getValue())
            );
            
            if (page.getRecords().isEmpty()) {
                break;
            }
            
            // 批量处理
            page.getRecords().forEach(order -> {
                reconcileOrder(order);
            });
            
            totalProcessed += page.getRecords().size();
            pageNum++;
            
            log.info("对账进度: {}/{}", totalProcessed, page.getTotal());
        }
        
        return ReconcileResult.builder()
            .date(date)
            .totalCount(totalProcessed)
            .build();
    }
}
```

**预计时间**: 4小时  
**验收标准**: 处理100万订单无OOM

---

#### 任务4: 数据库优化 🗄️ 优先级P1
**慢查询分析**:
```sql
-- 启用慢查询日志
ALTER SYSTEM SET log_min_duration_statement = 500;

-- 查看TOP 10慢查询
SELECT query, calls, total_time, mean_time
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;
```

**添加索引**:
```sql
-- 订单表索引
CREATE INDEX idx_tenant_start_time 
ON charging_order(tenant_id, start_time);

CREATE INDEX idx_charger_status 
ON charging_order(charger_id, status);

-- 充电桩表索引
CREATE INDEX idx_station_status 
ON charger(station_id, status);

-- 计费计划表索引
CREATE INDEX idx_station_valid 
ON billing_plan(station_id, valid_from, valid_to);
```

**预计时间**: 6小时  
**验收标准**: 慢查询减少80%

---

#### 任务5: 性能压测 🎯 优先级P1
**压测目标**:
- 订单创建: 500 TPS
- 订单查询: 1000 TPS
- 充电桩状态更新: 2000 TPS

**JMeter场景**:
```xml
<ThreadGroup name="订单创建">
    <numThreads>50</numThreads>
    <rampUp>10</rampUp>
    <HTTPSampler path="/api/order/start"/>
</ThreadGroup>

<ThreadGroup name="订单查询">
    <numThreads>100</numThreads>
    <rampUp>10</rampUp>
    <HTTPSampler path="/api/order/list"/>
</ThreadGroup>
```

**监控指标**:
- P50/P95/P99响应时间
- 错误率
- CPU/内存使用率
- 数据库连接池使用率

**预计时间**: 8小时  
**验收标准**: 所有指标达标

---

**第4周总结**:
- 总工作量: 约30小时
- 验收标准:
  - ✅ 缓存一致性测试通过
  - ✅ 对账处理百万级数据无OOM
  - ✅ 慢查询减少80%
  - ✅ 性能指标达标

---

### 🟢 第5周：前端管理界面开发

**为什么重要**:
- 提供可视化管理界面
- 提升运营效率
- 完善用户体验

**核心任务清单**:

#### 任务1: 前端功能完善 🎨 优先级P2
**现状**: evcs-admin基础结构已完成（Vue 3 + Vite + Element Plus）

**需要完善的功能**:
1. **租户管理界面**
   - 租户列表（分页、搜索）
   - 租户树形结构展示
   - 租户新增/编辑表单
   - 租户详情页

2. **充电站管理界面**
   - 充电站列表（卡片/列表视图切换）
   - 地图展示（高德地图集成）
   - 充电站详情页
   - 充电桩实时状态监控

3. **订单管理界面**
   - 订单列表（高级搜索）
   - 订单详情页（充电时间轴）
   - 订单统计Dashboard
   - 导出Excel功能

4. **计费配置界面**
   - 计费计划列表
   - 分段可视化编辑器
   - 24小时时间轴预览

**预计时间**: 20小时  
**验收标准**: 所有核心功能可用，响应式设计良好

---

### 🟢 第6周：代码质量提升

**为什么重要**:
- 提升代码可维护性
- 减少技术债务
- 统一代码风格

**核心任务清单**:

#### 任务1: 移除手动租户过滤 🧹 优先级P2
**问题**: 部分代码手动添加 `WHERE tenant_id = ?`，与MyBatis Plus自动过滤冲突

**清理范围**:
```java
// 查找所有手动过滤的代码
// evcs-order/src/**/*.java
// evcs-station/src/**/*.java
// evcs-tenant/src/**/*.java

// 删除类似代码:
wrapper.eq("tenant_id", TenantContext.getCurrentTenantId())
```

**预计时间**: 4小时

---

#### 任务2: JSON处理优化 📝 优先级P2
**问题**: 手动拼接JSON字符串，可能导致格式错误

**修复方案**:
```java
// 替换前:
String body = "{\"code\":401,\"message\":\"" + message + "\"}";

// 替换后:
Result<?> result = Result.error(401, message);
String body = objectMapper.writeValueAsString(result);
```

**预计时间**: 4小时

---

#### 任务3: TODO清理 ✅ 优先级P2
**9个TODO项**:
1. `UserServiceImpl.refreshToken()` - Token刷新
2. `AuthController.getCurrentUser()` - 获取当前用户
3. 充电桩事件机制 - 使用Spring Event
4. DataScope权限检查 - 基于角色
5. 租户类型和祖级路径查询
6. 租户业务数据检查
7. 站点检查逻辑
8. RequestId Filter
9. 其他零散TODO

**预计时间**: 12小时  
**验收标准**: 所有TODO清理完成

---

**第6周总结**:
- 总工作量: 约20小时
- 验收标准:
  - ✅ 无手动tenant_id过滤
  - ✅ SonarQube代码质量A级
  - ✅ 所有TODO清理完成

---

### 🔴 第8周：测试与发布准备

**为什么最重要**:
- 确保质量
- 准备生产发布
- 项目交付

**核心任务清单**:

#### 任务1: 单元测试补充 🧪 优先级P1
**目标**: 覆盖率从~40%提升到≥80%

**重点测试**:
- Service层业务逻辑
- Controller层参数验证
- Util工具类边界条件
- 多租户隔离测试

**预计时间**: 16小时

---

#### 任务2: 集成测试 🔗 优先级P1
**端到端场景**:
1. 完整充电流程（开始→充电→结束→支付→对账）
2. 支付流程（下单→支付→回调→完成）
3. 多租户隔离（租户A数据对租户B不可见）

**预计时间**: 8小时

---

#### 任务3: 文档完善 📚 优先级P1
**需要更新的文档**:
1. API文档（Swagger导出）
2. 部署运维手册（Docker + K8s）
3. 开发者指南（新模块开发、代码规范）
4. 故障排查手册（常见问题FAQ）

**预计时间**: 8小时

---

#### 任务4: 发布准备 🚀 优先级P1
**清单检查**:
- ✅ 代码审查完成
- ✅ 测试用例通过
- ✅ 文档更新完成
- ✅ 性能测试达标
- ✅ 安全扫描通过

**灰度发布计划**:
- Day 1: 5%流量
- Day 2: 20%流量
- Day 3: 50%流量
- Day 4: 100%全量

**预计时间**: 8小时

---

**第8周总结**:
- 总工作量: 约40小时
- 验收标准:
  - ✅ 单元测试覆盖率≥80%
  - ✅ 集成测试全部通过
  - ✅ 文档齐全
  - ✅ 发布清单完成

---

## 三、关键风险与应对策略 ⚠️

### 风险1: 时间不足
**概率**: 中  
**影响**: 高  
**应对**: 
- 优先完成P0/P1任务
- P2任务可延期到下一阶段
- 第8周可延长1周作为缓冲

### 风险2: 协议设备不可用
**概率**: 中  
**影响**: 高  
**应对**: 
- 提前准备OCPP模拟器
- 联系云快充厂商获取沙箱
- 使用协议调试工具模拟

### 风险3: 性能目标未达标
**概率**: 低  
**影响**: 高  
**应对**: 
- 第4周提前压测
- 预留优化时间
- 必要时降低部分指标

### 风险4: 多租户数据泄漏
**概率**: 低  
**影响**: 极高  
**应对**: 
- 专项安全测试
- 代码审查重点关注
- 增加并发测试场景

---

## 四、成功标准 🎯

### 功能完整性
- ✅ P0级别问题100%修复
- ✅ P1级别功能100%完成
- ✅ P2级别功能80%+完成

### 性能指标
| 指标 | 目标 | 测量方法 |
|------|------|---------|
| 订单创建接口 | 500 TPS | JMeter压测 |
| 订单查询接口 | 1000 TPS | JMeter压测 |
| 充电桩状态更新 | 2000 TPS | JMeter压测 |
| 接口P99延迟 | < 200ms | Prometheus |

### 质量指标
| 指标 | 目标 | 测量方法 |
|------|------|---------|
| 单元测试覆盖率 | ≥ 80% | JaCoCo |
| 代码重复率 | < 5% | SonarQube |
| 严重Bug数 | 0 | Jira |
| 安全漏洞 | 0高/中危 | 安全扫描 |

### 运维指标
| 指标 | 目标 | 测量方法 |
|------|------|---------|
| 服务可用性 | ≥ 99.9% | Uptime监控 |
| 故障恢复时间 | < 5分钟 | 事件记录 |

---

## 五、每周交付物清单 📦

### 第1周
- [ ] Java 21环境配置文档
- [ ] JWT安全修复代码
- [ ] 租户上下文增强代码
- [ ] 安全测试报告

### 第2周
- [ ] 协议事件模型代码
- [ ] RabbitMQ配置文件
- [ ] 协议适配器实现
- [ ] 协议对接文档

### 第4周
- [ ] Redis缓存服务代码
- [ ] 对账优化代码
- [ ] 数据库索引DDL脚本
- [ ] 性能测试报告

### 第5周
- [ ] 前端管理界面代码
- [ ] 前端部署文档

### 第6周
- [ ] 代码质量改进提交
- [ ] SonarQube扫描报告
- [ ] TODO清理清单

### 第8周
- [ ] 单元测试代码（覆盖率≥80%）
- [ ] 集成测试代码
- [ ] 完整API文档
- [ ] 部署运维手册
- [ ] 发布Checklist

---

## 六、建议的工作流程 🔄

### 每日工作流程
1. **09:00 - 09:15** 站会（昨天完成、今天计划、阻塞问题）
2. **09:15 - 12:00** 编码时间（2-3小时专注编码）
3. **12:00 - 13:30** 午休
4. **13:30 - 15:00** 继续编码
5. **15:00 - 16:00** 代码审查/测试
6. **16:00 - 17:00** 文档更新/学习时间
7. **17:00 - 17:30** 日报提交

### 每周工作流程
- **周一**: 周计划制定，任务分配
- **周二-周四**: 专注开发，代码审查
- **周五**: 集成测试，周报总结
- **周末**: 可选加班（紧急情况）

---

## 七、立即行动建议 🚀

### 今天（2025-10-11）
- [x] 完成下一步工作规划文档（本文档）
- [ ] 检查Java环境版本
- [ ] 阅读JWT白名单漏洞代码
- [ ] 准备第1周任务清单

### 明天（2025-10-12）
- [ ] 开始Java版本升级
- [ ] 更新CI/CD配置
- [ ] 验证构建通过

### 本周剩余时间（2025-10-13 - 2025-10-15）
- [ ] 修复JWT白名单漏洞
- [ ] 完善租户上下文清理
- [ ] 修复异常处理器顺序
- [ ] 编写安全测试报告

---

## 八、参考文档 📚

### 项目规划文档
- [下一步行动计划](./下一步行动计划.md) - 详细8周计划
- [P3每周行动清单](./P3每周行动清单.md) - 每周任务清单
- [PROGRESS.md](./PROGRESS.md) - 进度跟踪
- [ROADMAP.md](./ROADMAP.md) - 项目路线图

### 技术文档
- [DEVELOPMENT-PLAN.md](./DEVELOPMENT-PLAN.md) - 开发计划
- [TECHNICAL-DESIGN.md](./TECHNICAL-DESIGN.md) - 技术设计
- [MONITORING-GUIDE.md](./MONITORING-GUIDE.md) - 监控指南
- [TESTING-GUIDE.md](./TESTING-GUIDE.md) - 测试指南

### 完成总结
- [M3-COMPLETION-SUMMARY.md](./M3-COMPLETION-SUMMARY.md) - 支付集成完成
- [M7-COMPLETION-SUMMARY.md](./M7-COMPLETION-SUMMARY.md) - 监控体系完成

---

## 九、联系方式 📞

**项目经理**: [待填写]  
**技术负责人**: [待填写]  
**下次评审**: 2025-10-18（第1周结束）

---

## 十、总结 📝

### 核心要点
1. **第1周（安全加固）是基础**，必须完成才能继续后续工作
2. **第2周（协议对接）是核心**，影响充电桩业务功能
3. **第4周（性能优化）是关键**，决定系统能否支撑高并发
4. **第8周（测试发布）是保障**，确保质量和稳定性

### 工作量预估
- 第1周: 14小时
- 第2周: 34小时
- 第4周: 30小时
- 第5周: 20小时
- 第6周: 20小时
- 第8周: 40小时
- **总计**: 约158小时（约20个工作日）

### 关键成功因素
1. **安全第一**: P0问题不解决，不进入后续开发
2. **小步快跑**: 每周有明确交付物和验收标准
3. **质量保证**: 代码审查 + 测试 + 文档同步更新
4. **风险管理**: 提前识别风险，准备应对方案
5. **团队协作**: 及时沟通，遇到问题立即寻求帮助

---

**文档维护人**: GitHub Copilot  
**创建日期**: 2025-10-11  
**最后更新**: 2025-10-11  
**版本**: v1.0

---

**祝项目顺利！🎉**
